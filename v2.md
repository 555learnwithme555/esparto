![ESPARTO Logo](/assets/espartotitle.png)
# Asynchronous programming framework for ESP8266 Arduino IDE
## What is Esparto?

"Asynchronous programming framework" is a bit of a mouthful - what exactly does it mean? It's a way of writing code that removes many common problems when getting to grips with the ESP8266.

It supports the "event-driven" style that allows the ESP8266 to function at its best and relies on "callbacks" to nofify you when your code should be run. Each of these topics is a subject in itself (more information can be found here: https://8266iot.blogspot.fr/p/you-need-to-read-this-first.html and here: https://8266iot.blogspot.fr/p/event-driven-style-how.html Suffice to say that you will get far less errors, far less frustration and much shorter development times using **Esparto**.

At it's simplest: Real-time embedded programming is hard to do *properly*. The ESP8266 has a lot of "gotchas" for folk coming from other embedded systems - **Esparto** a) makes it foolproof b) hides most of the complex nastiness that *"doing it properly"* requires.

### ESPARTO Main features:
Ease of use:
* Extremely simple programming interface for Arduino IDE.
* Numerous working examples provided
* Flexibilty: features from simple "blinky" type apps to fully-featured complex resilient firmware

Rapid development:
* Most common errors avoided
* Many flexible input-pin options pre-configured
* Full MQTT controlled firmware in only 15 lines of code!

“Industrial strength”:
* Copes resiliently with WiFi outage or total network loss, reconnecting automatically with reboot
* Supports OTA
* Hardware features continue to function at all times irrespective of connection status
* Never* reboots (*fingers crossed! Except of course after OTA update)
* Serialises all events into user-mode task queue (mutex-protected), avoiding WDT reset
* Web UI showing real-time GPIO status
* MQTT support for get/set any pin 

**Esparto** does a lot of the ESP8266 "heavy lifting" for you and allows you to concentrate on just the code that your specific hardware needs. It comes in three "flavours" which can be used depending on your exisitng skill level or complexity of your code requirements

* Esparto Lite - ideal for beginners and/or "quick and dirty" examples/tests that dont need WiFi
* Esparto WiFi - adds a web UI showing the GPIO status in real-time allows users to easily add their own web pages
* Esparto MQTT - adds full remote control functionality..."firmware-in-a-box" fpr more advanced users

# ESPArtoLite

blah blah

# ESPArtoWiFi

pics blah blah

# ESPArtoMQTT

more blah



## Installation Implementation

ESPARTO is implemented as an Arduino library – there are plenty of places which describe how to download and install these. 

It requires the following libraries, which must be installed before installing ESPARTO:

H4
SmartPins
ESPAsyncTCP
arduinoWebSockets
PubSubClient	https://github.com/knolleary/pubsubclient

### What you need to know first:

Unlike most other Arduino sketches, no `setup()` or `loop()` function is needed (or allowed) in your code, to allow ESPARTO to control the “correct” order of doing things to maintain resilience. You provide a number of “callback” functions (e.g. to subscribe to your own MQTT topics, or take action when WiFi disconnects) and these will be called at the appropriate time.

All asynchronous events e.g. external H/W pin activity, timers etc are serialised into a task queue. The main loop pulls the next task from the queue and executes it. The taskQ is protected by a “mutex” meaning that only one event can update it at a time, preventing hidden resource clashes. The general rule is that if your callback does anything more than a few lines of bit-twiddling, you need to separate that code into a function and call ESPARTO’s “queueFunction(your_function)” to put it in the queue. This way, none of the “important” stuff will be delayed for too long and you minimise the risk of a WDT reset or crash.

Since only one "task" can be running at one time, there is no need for complex code to synchronise processes...for example you don't need to declare globals "volatile" since the can't - by definiton - be accessed "simultaneously".

Even so, badly-written code in your callbacks (e.g. long delays, waiting for external resources etc) can still crash the system.




© 2017 Phil Bowles
philbowles2012@gmail.com
http://www.github.com/philbowles
